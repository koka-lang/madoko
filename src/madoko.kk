/*---------------------------------------------------------------------------
  Copyright 2013 Microsoft Corporation.
 
  This is free software; you can redistribute it and/or modify it under the
  terms of the Apache License, Version 2.0. A copy of the License can be
  found in the file "license.txt" at the root of this distribution.
---------------------------------------------------------------------------*/

// Parse Madoko markdown text.
module madoko

import std/dict
import std/regex
import common
import options
import metadata
import block
import formatBlock
import inline
import formatInline
import definitions
import htmlFormatter    // for full
import texFormatter     // for full
import attributes       // expandKeys
import std/log

/* --------------------------------------
  Main library entry point 
---------------------------------------- */

// Takes source markdown input and returns formatted html
public function markdown( src : string, 
                          options : options = initialOptions0, 
                          fmt : formatter = FmtHtml 
                        ) : pure string
{
  if (options.xmp) then markdownXmp(src,options,fmt) else markdownNormal(src,options,fmt)
}

// Process only markdown between <xmp> tags 
function markdownXmp( src : string, options : options = initialOptions0, fmt : formatter = FmtHtml ) : pure string
{
  src.replaceAll( rxxmp ) fun(cap) {
    // trace("xmp: " + cap.groups[1])
    markdownNormal(cap.groups[1],options,fmt)
  }
}
val rxxmp = regex(@"<xmp\b" + tagContent + @">([\s\S]*?)</xmp>")

public function normalizeSource( src : string ) : string {
  val srcnl = if (src.contains('\r')) then src.replaceAll(regex(@"\r\n?"),"\n") else src
  srcnl.replaceAll(regex(@"\t"), "    ") 
}

// Takes source markdown input and returns formatted html
function markdownNormal( src0 : string, options0 : options = initialOptions0, fmt : formatter = FmtHtml ) : pure string
{  
  // first normalize the input: all tabs to 4 spaces.
  val (options1,src) = parseMeta(options0,fmt,src0.normalizeSource)
  val options = options1(metadata = options1.metadata.completeAuthorKeys).filterMeta
  val xfull = options.full.maybe(True,id)     
  val logo  = if (xfull && options.logo) then "\n\n~Begin LogoMadoko\n&LogoMadoko;\n~End LogoMadoko\n" else "\n"
  
  if (options.verbose>=4) then trace("parse blocks")
  //val blocks = parseBlocks(src,options.citestyle,options.bench,options.pedantic )

  if (options.citeAll) then log("aux",@"\citation{*}");
  
  // parse definitions
  val icontext  = inlineContext(fmt,options.metadata.dict,
                                    options.mathdim,
                                    options.embedinfos, 
                                    options.citestyle,
                                    options.sanitize,options.bench,options.verbose,
                                    options.mathmode.isStatic,
                                    options.highlight,options.starBold,options.prettyAlign) 
  //if (options.verbose > 2) then trace("process definitions")
  val (fblocks,fcontext) 
    = parseBody(initialFormatContext(icontext,options.lineMap,options.titleInfo(icontext.metadata),
                                      options.headingBase,options.pedantic,fmt), 
                options.lineNo,
                src + logo,
                options.metadata, options.tocDepth,
                options.sectionBase,options.sectionMax)

  // parse inline elements
  if (options.verbose>=4) then trace("parse inline")
  val body = //(if (options.autoCount) then "<!-- generated by MarkedX -->\n" else "") + 
             formatBlocks(fcontext,fblocks)
  if (options.verbose>=4) then trace("generate output")

  // log links and labels
  if (fmt.isFmtHtml) {
    fcontext.inlineContext.labels.list().foreach fun(elem) {
      val (name,label) = elem
      log("labels","{ \"name\": " + name.json + ", \"text\": " + label.labelText.json + ", \"caption\": " + label.labelCaption.json + " }" );
    }
    fcontext.inlineContext.links.list().foreach fun(elem) {
      val (name,link) = elem
      log("links","{ \"name\": " + name.json + ", \"href\": " + link.href.json + ", \"title\": " + link.title.json + " }" );
    }
  }

  // generate full html/tex if needed
  val res = if (xfull) 
             then (fmt.pick(fmtHtmlFull,fmtTexFull))(body,options,fcontext.inlineContext.metadata)
             else body 
  // emit file references if necessary
  if (!xfull || !(fmt.isFmtHtml)) then fmtHtmlFull("",options,fcontext.inlineContext.metadata) else ""
  if (!xfull || !(fmt.isFmtTex))  then fmtTexFull("",options,fcontext.inlineContext.metadata) else ""
  
  if (options.verbose>=4) then trace("done")
  res           
}

function json(s : string) : string {
  val cs = s.list.map fun(c) {
    if (c=='\n') then "\\n"
    elif (c=='\r') then "\\r"
    elif (c=='\t') then "\\t"
    elif (c=='"') then "\\\""
    elif (c=='\\') then "\\\\"
    elif (c >= ' ' && c <= '~') then c.string
    else "\\u" + c.int.showHex(4)
  }
  return "\"" + cs.join + "\""
}

function titleInfo( options : options, metadata : dict<string> ) : div titleinfo {
  function expand(s) { s.expandKeys(metadata) }  
  val authors = zipAuthors(options.author.map(expand), options.affiliation.map(expand), 
                           options.email.map(expand), options.authorNotes.map(expand)) 
  Titleinfo(options.title.expand, options.subtitle.expand, authors, options.titleNote.expand)
}

function zipAuthors(xs,ys,zs,qs,acc=[]) : div list<authorinfo> {
  function zipZs(x,xx,y,yy) {
    function zipQs(z,zz) {
      match(qs) {
        Nil -> zipAuthors(xx,yy,zz,qs,Cons(Authorinfo(x,y,z,""),acc))
        Cons(q,qq) -> zipAuthors(xx,yy,zz,qq,Cons(Authorinfo(x,y,z,q),acc))
      }
    }           

    match(zs) {
      Nil -> zipQs("",Nil)
      Cons(z,zz) -> zipQs(z,zz) 
    }
  }

  match(xs) {
    Nil -> acc.reverse
    Cons(x,xx) -> {
      match(ys) {
        Nil -> zipZs(x,xx,"",Nil)
        Cons(y,yy) -> zipZs(x,xx,y,yy)
      }
    }
  }
}


// Export initial options for JavaScript usage
public val initialOptions0 = initialOptions();

public function initialOptions() {
  return Options();
}

public function traceRuleHist() {
  common/traceRuleHist()
}
